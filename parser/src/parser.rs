// This file is auto-generated by parsergens, not meant for manual editing.

#![allow(dead_code, non_camel_case_types, unused_parens, unused_mut)]
#![allow(unused_variables, unused_braces, non_snake_case)]

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum TokenKind {
  Do = 37,
  Lparen = 20,
  Colon = 7,
  Then = 33,
  And = 16,
  Gt = 3,
  LitStr = 45,
  Of = 28,
  Mod = 15,
  In = 41,
  Type = 24,
  Plus = 11,
  To = 36,
  Rbrack = 23,
  Assign = 6,
  If = 32,
  Rbrace = 19,
  Lt = 2,
  LitInt = 44,
  Function = 31,
  Div = 14,
  Let = 40,
  Array = 27,
  Semi = 10,
  Ge = 5,
  Break = 39,
  Lbrack = 22,
  Neq = 1,
  For = 35,
  Lbrace = 18,
  Times = 13,
  Nil = 30,
  Dot = 9,
  Ident = 43,
  String = 26,
  Rparen = 21,
  Le = 4,
  While = 38,
  Or = 17,
  Eq = 0,
  Else = 34,
  Var = 29,
  Minus = 12,
  Int = 25,
  Comma = 8,
  End = 42,
}

static DFA_TRANSITIONS: [(u32, u32); 321] = [
    (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0), 
    (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0), 
    (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),   (0, 0),  (2, 18),   (6, 1), 
   (8, 29),   (0, 0),  (8, 29),  (8, 29),  (8, 29),   (8, 9),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 30),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), 
   (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29),  (8, 29), (13, 14),  (13, 0), 
   (13, 0),  (13, 0),  (13, 0),  (13, 0),  (13, 0), (13, 14),  (13, 0),  (13, 0), 
   (13, 0),  (13, 0), (13, 14),  (13, 0), (13, 14), (13, 14), (13, 14), (13, 14), 
  (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), 
  (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), 
  (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (13, 14), (21, 16),  (21, 5), 
   (13, 0), (24, 25),  (14, 0), (24, 25),  (14, 0),  (14, 0),  (14, 0),  (14, 0), 
   (14, 0),  (14, 0),  (14, 0),  (14, 0),  (14, 0),  (14, 0),  (14, 0),  (14, 0), 
   (14, 0), (28, 29), (23, 24), (28, 29), (28, 29), (28, 29),  (28, 9), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 30), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), 
  (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29), (28, 29),  (29, 0), 
   (29, 0),  (29, 0),  (29, 0),  (29, 0), (29, 29),  (29, 0),  (29, 0),  (29, 0), 
   (29, 0),  (29, 0),  (29, 0),  (29, 0),  (29, 0),  (29, 0),  (29, 0),  (29, 0), 
   (29, 0), (29, 33),  (29, 0),  (29, 0),  (29, 0), (30, 25),  (29, 0), (30, 25), 
   (29, 0), (30, 29), (29, 29), (30, 11),  (30, 6),  (29, 0),  (30, 2), (30, 15), 
  (30, 10), (30, 13), (30, 27), (30, 23), (30, 12), (30, 26), (30, 24),  (30, 3), 
  (30, 28), (30, 22), (30, 20),  (30, 7), (29, 29), (30, 14),  (30, 4), (31, 29), 
  (30, 17), (32, 32), (29, 29),  (29, 0), (30, 14), (30, 14), (30, 14), (30, 14), 
  (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), 
  (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), 
  (30, 14), (30, 14), (30, 14), (30, 14), (30, 14), (30, 14),  (30, 8), (30, 19), 
  (30, 21),  (30, 0),  (31, 0),  (31, 0),  (31, 0),  (31, 0),  (31, 0),  (31, 0), 
   (31, 0),  (31, 0),  (31, 0),  (32, 0),  (32, 0),  (33, 0),  (33, 0),  (33, 0), 
   (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0), 
   (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0),  (33, 0), 
   (33, 0), 
];

static DFA_STATE_DISP: [usize; 34] = [
    0,   0,   0,   0,   0,   0,   1,   1,  24,  25,  25,  25,  25,  68,  87,  87, 
   87,  87,  87,  87,  87, 104, 128, 128, 128, 128, 128, 128, 145, 207, 228, 237, 
  239, 259, 
];

static LEXER_CHAR_INTERVALS: [u32; 62] = [
    0,  10,  11,  32,  33,  34,  35,  37,  38,  39,  40,  41,  42,  43,  44,  45, 
   46,  47,  48,  58,  59,  60,  61,  62,  63,  65,  91,  92,  93,  94,  95,  96, 
   97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 
  113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 
];

const DFA_START: u32 = 30;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Token<'input> {
  pub kind: TokenKind,
  pub text: &'input str,
  pub start: usize,
  pub end: usize,
}

pub struct Tokens<'input> {
  input: &'input str,
  pos: usize,
}

#[derive(Debug, Clone)]
pub struct Error {
  pub char: char,
  pub start: usize,
  pub end: usize,
}

pub fn lex(input: &str) -> Tokens {
  Tokens::new(input)
}

impl<'input> Tokens<'input> {
  fn new(input: &'input str) -> Self {
    Self {
      input,
      pos: 0,
    }
  }

  fn peek_char(&mut self) -> Option<char> {
    self.input[self.pos..].chars().next()
  }

  fn advance(&mut self) {
    self.pos += 1;

    while !self.input.is_char_boundary(self.pos) {
      self.pos += 1;
    }
  }
}

fn find_char_interval(char: u32, char_intervals: &[u32]) -> u32 {
  let mut lo = 0;
  let mut hi = char_intervals.len();

  while lo < hi {
    let mid = (lo + hi) / 2;
    if char_intervals[mid] > char {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  lo as u32 - 1
}

fn transition(state: u32, c: u32) -> Option<u32> {
  let tx = DFA_TRANSITIONS[DFA_STATE_DISP[state as usize] + c as usize];

  if tx.0 == state && tx.1 != 0 {
    Some(tx.1 - 1)
  } else {
    None
  }

}

impl<'input> Iterator for Tokens<'input> {
  type Item = ::std::result::Result<Token<'input>, Error>;

  fn next(&mut self) -> ::std::option::Option<Self::Item> {
    #[allow(unused_imports)]
    use ::std::option::Option::{self, *};

    if self.pos == self.input.len() {
      return Option::None;
    }

    let mut state = DFA_START;
    let mut start = self.pos;
    let mut end = start;
    let mut token_kind: Option<TokenKind> = None;

    loop {
      let no_move;

      match self.peek_char() {
        Some(c) => {
          let char_interval = find_char_interval(
            c as u32, &LEXER_CHAR_INTERVALS);

          if let Some(next_state) = transition(state, char_interval) {
            self.advance();
            state = next_state;
            no_move = false;
          } else {
            no_move = true;
          }
        }
        None => {
          no_move = true;
        }
      }

      if no_move {
        self.pos = end;

        if end == start {
          let char = self.peek_char().unwrap();
          let start = self.pos;
          self.advance();
          let end = self.pos;

          return Some(Err(Error {
            char,
            start,
            end,
          }));
        } else if let Some(kind) = token_kind {
          return Some(Ok(Token {
            kind,
            text: &self.input[start..end],
            start,
            end,
          }));
        } else if end == self.input.len() {
          return None;
        } else {
          state = DFA_START;
          start = end;
          continue;
        }
      }
      match state {
        24 => { end = self.pos; token_kind = None; }
        16 => { end = self.pos; token_kind = Some(TokenKind::Rbrack); }
        3 => { end = self.pos; token_kind = Some(TokenKind::Lbrack); }
        11 => { end = self.pos; token_kind = Some(TokenKind::Dot); }
        19 => { end = self.pos; token_kind = Some(TokenKind::Eq); }
        2 => { end = self.pos; token_kind = Some(TokenKind::Colon); }
        27 => { end = self.pos; token_kind = Some(TokenKind::Semi); }
        10 => { end = self.pos; token_kind = Some(TokenKind::Mod); }
        5 => { end = self.pos; token_kind = Some(TokenKind::And); }
        18 => { end = self.pos; token_kind = Some(TokenKind::Or); }
        13 => { end = self.pos; token_kind = Some(TokenKind::Ident); }
        26 => { end = self.pos; token_kind = Some(TokenKind::Comma); }
        21 => { end = self.pos; token_kind = Some(TokenKind::Lt); }
        4 => { end = self.pos; token_kind = Some(TokenKind::Neq); }
        12 => { end = self.pos; token_kind = Some(TokenKind::Plus); }
        20 => { end = self.pos; token_kind = Some(TokenKind::Rbrace); }
        7 => { end = self.pos; token_kind = Some(TokenKind::Lbrace); }
        15 => { end = self.pos; token_kind = Some(TokenKind::Le); }
        23 => { end = self.pos; token_kind = Some(TokenKind::LitInt); }
        6 => { end = self.pos; token_kind = Some(TokenKind::Gt); }
        14 => { end = self.pos; token_kind = Some(TokenKind::Rparen); }
        22 => { end = self.pos; token_kind = Some(TokenKind::Minus); }
        1 => { end = self.pos; token_kind = Some(TokenKind::Lparen); }
        9 => { end = self.pos; token_kind = Some(TokenKind::Times); }
        17 => { end = self.pos; token_kind = Some(TokenKind::Assign); }
        0 => { end = self.pos; token_kind = Some(TokenKind::Ge); }
        25 => { end = self.pos; token_kind = Some(TokenKind::Div); }
        8 => { end = self.pos; token_kind = Some(TokenKind::LitStr); }
        _ => {}
      }
      }
  }
}

static PARSE_TABLE: [i32; 399] = [
   32,  33,  34,  35,  30,  31,  42,  36,  37,  38,  39,  42,  36,  37,  38,  39, 
   40,  41,  32,  33,  34,  35,  30,  31,  37,  38,  39,  19,  20,  42,  36,  37, 
   38,  39,  40,  41,  45,  49, 116,  29,  28,  32,  33,  34,  35,  30,  31,  59, 
   51,  98,  63,  50,  42,  36,  37,  38,  39,  40,  41,  62,  80,  90,  45, 117, 
   81,  32,  33,  34,  35,  30,  31, -28,  88,  43,  89,  44,  42,  36,  37,  38, 
   39,  40,  41,  91,  92,  99, 102,  95,  96,  32,  33,  34,  35,  30,  31, 103, 
  101, 105, 109, 119,  42,  36,  37,  38,  39,  40,  41, 130, 129, 131, 121, 133, 
  135,  32,  33,  34,  35,  30,  31,   8,  17, 137, 139, 100,  42,  36,  37,  38, 
   39,  40,  41,  32,  33,  34,  35,  30,  31,  87, 142, 146, 144, 147,  42,  36, 
   37,  38,  39,  40,  41, 108, 120,  46,  84,   0, 126,  32,  33,  34,  35,  30, 
   31,   0,   0,   0,   0,  45,  42,  36,  37,  38,  39,  40,  41,   6,   0,  52, 
    0,   0,  98,   0,  53,   9,  54,  86, 110,   0,   8,  17,   0,   0,   0,  15, 
  132,   4,   0,   0,  13,   0,   0,   3,  11,   7,   0,   0,  18,   5,  16,  32, 
   33,  34,  35,  30,  31,  97,   0,   0,   0,   0,  42,  36,  37,  38,  39,  40, 
   41,  32,  33,  34,  35,  30,  31,  85,   0,   0, 118,   0,  42,  36,  37,  38, 
   39,  40,  34,  35,  30,  31,   0,   0,   0,   0,   0,  42,  36,  37,  38,  39, 
   14,   0,   0,  21,  22, 136,  23,   0,   0,   0, 140,   0,   0,   0,   0,   0, 
    0,   0,   0,  47,  48,   0, 148,   0,   0,   0,  85,   0,   0,   0,  64,  65, 
   66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  79,   0,   0,   0, 
    0,  82,  83,   0,   0,  85,   0,   0,   0,   0,  85,   0,   0,   0,   0,  93, 
    0,   0,   0,   0,   0,   0,  85,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 106,   0, 107,   0,   0,   0, 
    0,   0, 112, 113, 114,   0,   0,   0,   0,   0,   0,   0, 123, 124, 125,   0, 
    0,   0,   0,   0,   0,   0,   0, 128,   0,   0,   0,   0,   0,   0,   0,   0, 
    0,   0,   0,   0, 138,   0,   0,   0,   0,   0,   0, 143,   0,   0, 145, 
];

static CHECK_TABLE: [i32; 399] = [
   0,  1,  2,  3,  4,  5, 11, 12, 13, 14, 15, 11, 12, 13, 14, 15, 16, 17,  0,  1, 
   2,  3,  4,  5, 13, 14, 15,  6, 22, 11, 12, 13, 14, 15, 16, 17,  9, 37, 18, 43, 
  18,  0,  1,  2,  3,  4,  5, 21, 41, 22,  6, 33, 11, 12, 13, 14, 15, 16, 17, 43, 
  43, 10,  9, 43, 23,  0,  1,  2,  3,  4,  5, 18, 43, 20, 43, 22, 11, 12, 13, 14, 
  15, 16, 17, 19,  0, 28,  0, 21, 23,  0,  1,  2,  3,  4,  5,  7, 42, 20,  8,  6, 
  11, 12, 13, 14, 15, 16, 17,  7, 21,  8, 43, 19,  7,  0,  1,  2,  3,  4,  5, 25, 
  26, 43,  0, 34, 11, 12, 13, 14, 15, 16, 17,  0,  1,  2,  3,  4,  5, 43,  0, 43, 
   8,  7, 11, 12, 13, 14, 15, 16, 17, 36, 52, 58, 60, -1, 23,  0,  1,  2,  3,  4, 
   5, -1, -1, -1, -1,  9, 11, 12, 13, 14, 15, 16, 17, 12, -1, 24, -1, -1, 22, -1, 
  29, 20, 31, 53, 28, -1, 25, 26, -1, -1, -1, 30, 37, 32, -1, -1, 35, -1, -1, 38, 
  39, 40, -1, -1, 43, 44, 45,  0,  1,  2,  3,  4,  5, 58, -1, -1, -1, -1, 11, 12, 
  13, 14, 15, 16, 17,  0,  1,  2,  3,  4,  5, 54, -1, -1, 53, -1, 11, 12, 13, 14, 
  15, 16,  2,  3,  4,  5, -1, -1, -1, -1, -1, 11, 12, 13, 14, 15, 59, -1, -1, 59, 
  59, 53, 59, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, -1, 53, -1, 
  -1, -1, 54, -1, -1, -1, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 
  59, -1, -1, -1, -1, 59, 59, -1, -1, 54, -1, -1, -1, -1, 54, -1, -1, -1, -1, 59, 
  -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, 59, -1, 59, -1, -1, -1, -1, -1, 59, 59, 59, -1, -1, -1, 
  -1, -1, -1, -1, 59, 59, 59, -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1, -1, -1, 59, -1, -1, 59, 
];

static ACTION_DISP: [isize; 149] = [
  161,  21,   6, 161, 161, -47, 161, -47, -47, 161,  22, -47, -47,  -4, 207, -47, 
  -47, -47,  53, 161, 161,   0,  18, -47,   7, 151,  26, 207,  16,  44, 161, 161, 
  161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161,  17, -47, 207, 
   41, 161, 161, 161,  94,  29,  31, -47, -47, -47, -47, -47,  51,  64,  84, 161, 
   -5,  -5, 240, 240,  -5,  -5,  11, -47, -47, -47, 225, 207,  11, 207,  66,  65, 
   27,  57, 207,  89,  54, -47,  86, -47,  88,  77, 161, -47, 161, 113,  90, -47, 
  156, -47, 161, 161, 161, -47,  20,  94,  93,  67, 207, 207, 161, 161, 161, -47, 
  131, 207, -47, -47,  67, -47, -47, 161,  87, 100, 101, 155, 207, 207,  27,  92, 
  207, 105,  94,  78, 161, -47, 122,  94, -47, 138, 207, 161, -47, 132, 161, 207, 
   96, 207, 134,  94, -47, 
];

static GOTO_DISP: [isize; 24] = [
  -149, -149, -149, -149, -149,   45,  131,  179, -149, -149, -149,  133,  256, 
   101, -149, -149, -149, -149, -149, -149, -149, -149, -149, -149, 
];

static ACTION_DEFAULT: [i32; 149] = [
    0, -33, -27,   0,   0, -37,   0,  -7,  -6, -13,   0, -61, -71,   0, -29, -35, 
  -38,  -5, -22,   0,   0,   0,   0, -39,   0,  -9,   0, -11, -17,   0,   0,   0, 
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, -65,   0,   0, -70, -34, 
    0,   0,   0, -13,   0,   0,   0, -32, -31, -30,  -8, -36, -14,   0,   0,   0, 
  -49, -48, -50, -51, -47, -46, -45, -43, -42, -41, -52, -53, -44, -63,   0,   0, 
  -22,   0, -59, -58,   0, -27,   0, -28, -67,   0,   0, -54,   0,   0, -66, -40, 
  -22, -23,   0,   0,   0, -62,   0,   0,   0,  -3, -12, -15,   0,   0,   0, -24, 
    0, -56, -57, -10,  -3, -25, -68,   0,   0,   0, -18,   0, -64, -55, -22,   0, 
  -69, -19,   0,   0,   0, -26,   0,   0,  -1,   0, -60,   0, -20,  -4,   0, -21, 
    0, -16,   0,   0,  -2, 
];

static GOTO_DEFAULT: [i32; 24] = [
   12,  24,  58,  57, 115, 127,  10,   2,  56,  55,   1, 111,  27,  26,  78,  61, 
  141,  25,  60, 122, 134,  94, 104,   0, 
];

static PRODUCTIONS: [(usize, u32); 71] = [
  (0, 16), (5, 16),  (0, 5),  (4, 5),  (1, 7),  (1, 7), (0, 17), (2, 17), 
   (1, 1),  (4, 3), (0, 18), (3, 18), (0, 13), (2, 13), (0, 19), (5, 19), 
  (0, 15), (4, 15), (0, 20), (2, 20),  (8, 9), (0, 11), (3, 11), (4, 11), 
   (1, 4),  (3, 4),  (1, 6),  (1, 6),  (1, 0),  (1, 2),  (1, 2),  (1, 2), 
  (1, 12), (3, 12), (1, 12), (3, 12), (1, 12), (1, 12), (2, 12), (4, 12), 
  (3, 12), (3, 12), (3, 12), (3, 12), (3, 12), (3, 12), (3, 12), (3, 12), 
  (3, 12), (3, 12), (3, 12), (3, 12), (3, 12), (4, 12), (6, 12), (6, 12), 
  (6, 12), (4, 12), (4, 12), (8, 12), (1, 12), (5, 12), (0, 21), (3, 21), 
  (0, 14), (2, 14), (0, 22), (2, 22),  (5, 8), (2, 10), (1, 23), 
];

enum NtType<'input> {
  _Token(Token<'input>),
  r#program(()),
  r#decls(()),
  r#decl(()),
  r#type__decl(()),
  r#type(()),
  r#type__fields(()),
  r#type__id(()),
  r#predef__type(()),
  r#var__decl(()),
  r#fun__decl(()),
  r#lvalue(()),
  r#lvalue__suffix(()),
  r#expr(()),
  r#seq__exprs(()),
  r#arg__exprs(()),
  r#field__init__exprs(()),
  _xjlD3pdObG(Vec<(Token<'input>, Token<'input>, Token<'input>, (), )>),
  _TQ0g8Jjyjk(Vec<((), )>),
  _ELG7jkFWjz(Vec<(Token<'input>, (), )>),
  _kRgZOEjmGS(Vec<(Token<'input>, Token<'input>, Token<'input>, (), )>),
  _ufC6V3HNim(Option<(Token<'input>, (), )>),
  _cu4xtPtIkp(Vec<(Token<'input>, (), )>),
  _8MVOffr4bo(Option<(Token<'input>, (), )>),
  r#_program(()),
}

impl<'input> NtType<'input> {
  fn assert_token(self) -> Token<'input> {

    match self {
      Self::_Token(tok) => tok,
      _ => unreachable!(),
    }

  }

  fn assert_program(self) -> () {

    match self {
      Self::r#program(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_decls(self) -> () {

    match self {
      Self::r#decls(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_decl(self) -> () {

    match self {
      Self::r#decl(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_type__decl(self) -> () {

    match self {
      Self::r#type__decl(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_type(self) -> () {

    match self {
      Self::r#type(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_type__fields(self) -> () {

    match self {
      Self::r#type__fields(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_type__id(self) -> () {

    match self {
      Self::r#type__id(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_predef__type(self) -> () {

    match self {
      Self::r#predef__type(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_var__decl(self) -> () {

    match self {
      Self::r#var__decl(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_fun__decl(self) -> () {

    match self {
      Self::r#fun__decl(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_lvalue(self) -> () {

    match self {
      Self::r#lvalue(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_lvalue__suffix(self) -> () {

    match self {
      Self::r#lvalue__suffix(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_expr(self) -> () {

    match self {
      Self::r#expr(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_seq__exprs(self) -> () {

    match self {
      Self::r#seq__exprs(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_arg__exprs(self) -> () {

    match self {
      Self::r#arg__exprs(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert_field__init__exprs(self) -> () {

    match self {
      Self::r#field__init__exprs(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__xjlD3pdObG(self) -> Vec<(Token<'input>, Token<'input>, Token<'input>, (), )> {

    match self {
      Self::_xjlD3pdObG(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__TQ0g8Jjyjk(self) -> Vec<((), )> {

    match self {
      Self::_TQ0g8Jjyjk(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__ELG7jkFWjz(self) -> Vec<(Token<'input>, (), )> {

    match self {
      Self::_ELG7jkFWjz(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__kRgZOEjmGS(self) -> Vec<(Token<'input>, Token<'input>, Token<'input>, (), )> {

    match self {
      Self::_kRgZOEjmGS(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__ufC6V3HNim(self) -> Option<(Token<'input>, (), )> {

    match self {
      Self::_ufC6V3HNim(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__cu4xtPtIkp(self) -> Vec<(Token<'input>, (), )> {

    match self {
      Self::_cu4xtPtIkp(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__8MVOffr4bo(self) -> Option<(Token<'input>, (), )> {

    match self {
      Self::_8MVOffr4bo(v) => v,
      _ => unreachable!(),
    }

  }

  fn assert__program(self) -> () {

    match self {
      Self::r#_program(v) => v,
      _ => unreachable!(),
    }

  }
}

pub struct Parser<'input, I> {
  tokens: I,
  token: Option<Token<'input>>,
  token_kind: usize,
}

pub fn with_input<'input>(input: &'input str) -> Parser<'input, Tokens<'input>> {
  Parser::new(lex(input))
}

pub fn with_tokens<'input, I>(tokens: I) -> Parser<'input, I::IntoIter>
where I: IntoIterator<Item=::std::result::Result<Token<'input>, Error>>,
{
  Parser::new(tokens.into_iter())
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParseError<'input> {
  InvalidChar {
    char: char,
    start: usize,
    end: usize,
  },
  InvalidToken(Token<'input>),
  UnexpectedEof,
}

fn reduce<'input>(nt: usize, rhs: Vec<NtType<'input>>, user_state: &mut ()) -> NtType<'input> {
  match nt {
    0 => NtType::_xjlD3pdObG(vec![]),
    1 => {
      let mut rhs = rhs.into_iter();
      let mut result = rhs.next().unwrap().assert__xjlD3pdObG();
      result.push((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_type__id(),
      ));
      NtType::_xjlD3pdObG(result)
    }
    2 => NtType::r#type__fields(()),
    3 => NtType::r#type__fields(()),
    4 => NtType::r#predef__type(()),
    5 => NtType::r#predef__type(()),
    6 => NtType::_TQ0g8Jjyjk(vec![]),
    7 => {
      let mut rhs = rhs.into_iter();
      let mut result = rhs.next().unwrap().assert__TQ0g8Jjyjk();
      result.push((
        rhs.next().unwrap().assert_decl(),
      ));
      NtType::_TQ0g8Jjyjk(result)
    }
    8 => NtType::r#decls(()),
    9 => NtType::r#type__decl(()),
    10 => NtType::_ELG7jkFWjz(vec![]),
    11 => {
      let mut rhs = rhs.into_iter();
      let mut result = rhs.next().unwrap().assert__ELG7jkFWjz();
      result.push((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_expr(),
      ));
      NtType::_ELG7jkFWjz(result)
    }
    12 => NtType::r#seq__exprs(()),
    13 => NtType::r#seq__exprs(()),
    14 => NtType::_kRgZOEjmGS(vec![]),
    15 => {
      let mut rhs = rhs.into_iter();
      let mut result = rhs.next().unwrap().assert__kRgZOEjmGS();
      result.push((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_expr(),
      ));
      NtType::_kRgZOEjmGS(result)
    }
    16 => NtType::r#field__init__exprs(()),
    17 => NtType::r#field__init__exprs(()),
    18 => NtType::_ufC6V3HNim(None),
    19 => {
      let mut rhs = rhs.into_iter();
      NtType::_ufC6V3HNim(Some((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_type__id(),
      )))
    }
    20 => NtType::r#fun__decl(()),
    21 => NtType::r#lvalue__suffix(()),
    22 => NtType::r#lvalue__suffix(()),
    23 => NtType::r#lvalue__suffix(()),
    24 => NtType::r#type(()),
    25 => NtType::r#type(()),
    26 => NtType::r#type__id(()),
    27 => NtType::r#type__id(()),
    28 => NtType::r#program(()),
    29 => NtType::r#decl(()),
    30 => NtType::r#decl(()),
    31 => NtType::r#decl(()),
    32 => NtType::r#expr(()),
    33 => NtType::r#expr(()),
    34 => NtType::r#expr(()),
    35 => NtType::r#expr(()),
    36 => NtType::r#expr(()),
    37 => NtType::r#expr(()),
    38 => NtType::r#expr(()),
    39 => NtType::r#expr(()),
    40 => NtType::r#expr(()),
    41 => NtType::r#expr(()),
    42 => NtType::r#expr(()),
    43 => NtType::r#expr(()),
    44 => NtType::r#expr(()),
    45 => NtType::r#expr(()),
    46 => NtType::r#expr(()),
    47 => NtType::r#expr(()),
    48 => NtType::r#expr(()),
    49 => NtType::r#expr(()),
    50 => NtType::r#expr(()),
    51 => NtType::r#expr(()),
    52 => NtType::r#expr(()),
    53 => NtType::r#expr(()),
    54 => NtType::r#expr(()),
    55 => NtType::r#expr(()),
    56 => NtType::r#expr(()),
    57 => NtType::r#expr(()),
    58 => NtType::r#expr(()),
    59 => NtType::r#expr(()),
    60 => NtType::r#expr(()),
    61 => NtType::r#expr(()),
    62 => NtType::_cu4xtPtIkp(vec![]),
    63 => {
      let mut rhs = rhs.into_iter();
      let mut result = rhs.next().unwrap().assert__cu4xtPtIkp();
      result.push((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_expr(),
      ));
      NtType::_cu4xtPtIkp(result)
    }
    64 => NtType::r#arg__exprs(()),
    65 => NtType::r#arg__exprs(()),
    66 => NtType::_8MVOffr4bo(None),
    67 => {
      let mut rhs = rhs.into_iter();
      NtType::_8MVOffr4bo(Some((
        rhs.next().unwrap().assert_token(),
        rhs.next().unwrap().assert_type__id(),
      )))
    }
    68 => NtType::r#var__decl(()),
    69 => NtType::r#lvalue(()),
    70 => NtType::r#_program(()),
    _ => unreachable!(),
  }
}

impl<'input, I> Parser<'input, I>
where I: Iterator<Item=::std::result::Result<Token<'input>, Error>>,
{
  fn new(tokens: I) -> Self {

    Self {
      tokens,
      token: None,
      token_kind: 0,
    }

  }

  pub fn parse_program(&mut self) -> ::std::result::Result<(), ParseError<'input>> {
    Ok(self.parse(0, 70, ())?.assert_program())
  }

  fn get_token(&mut self) -> ::std::result::Result<(), ParseError<'input>> {

    let token = self.tokens.next()
      .transpose()
      .map_err(|err| ParseError::InvalidChar {
        char: err.char,
        start: err.start,
        end: err.end,
      })?;

    if let Some(token) = &token {
      self.token_kind = token.kind as usize;
    } else {
      self.token_kind = 46;
    }
    self.token = token;
    Ok(())
  }

  fn parse(&mut self, mut state: usize, mut accept_prod: usize, mut user_state: ()) -> ::std::result::Result<NtType<'input>, ParseError<'input>> {
    let mut stack = ::std::vec::Vec::<(usize, NtType)>::new();
    self.get_token()?;
    const GOTO_CHECK_BASE: i32 = 47;

    loop {
      let i = ACTION_DISP[state] + self.token_kind as isize;
      let action = if i < 0 || i as usize >= PARSE_TABLE.len() ||
        CHECK_TABLE[i as usize] != self.token_kind as i32
      {
        ACTION_DEFAULT[state]
      } else {
        PARSE_TABLE[i as usize]
      };

      if action > 0 {
        stack.push((state, NtType::_Token(self.token.take().unwrap())));
        state = action as usize;
        self.get_token()?;
      } else if action < 0 {
        let prod = (!action) as usize;
        if prod == accept_prod {
          return Ok(stack.pop().unwrap().1);
        }

        let (rhs_len, nt) = PRODUCTIONS[prod];
        let state0 = if rhs_len == 0 {
          state
        } else {
          stack[stack.len() - rhs_len].0
        };

        let i = GOTO_DISP[nt as usize] + state0 as isize;
        let check = GOTO_CHECK_BASE + nt as i32;
        state = if i < 0 || i as usize >= PARSE_TABLE.len() ||
          CHECK_TABLE[i as usize] != check
        {
          GOTO_DEFAULT[nt as usize] as usize
        } else {
          PARSE_TABLE[i as usize] as usize
        };

        let rhs = stack.drain(stack.len() - rhs_len..)
          .map(|(_, x)| x)
          .collect::<Vec<_>>();
        let ty = reduce(prod, rhs, &mut user_state);

        stack.push((state0, ty));
      } else {
        if let Some(token) = self.token.take() {
          return Err(ParseError::InvalidToken(token));
        } else {
          return Err(ParseError::UnexpectedEof);
        }
      }
    }

  }
}
